/*
  Service Worker for offline support and caching using Workbox
  - Precache static assets (built by Vite)
  - Runtime cache for rants API (adjust URL as needed)
*/

// Import Workbox from CDN
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Precache all of the assets generated by Vite (self.__WB_MANIFEST is injected at build time)
if (self.__WB_MANIFEST) {
    workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);
}

// Disable caching strategies by removing Workbox routes
workbox.routing.setDefaultHandler(() => {
    return fetch(event.request);
});

// Clear all caches during activation
self.addEventListener('activate', (event) => {
    event.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => caches.delete(cacheName))
            );
        })
    );
});

// Push notification event
self.addEventListener('push', function (event) {
    let data = {};
    try {
        data = event.data.json();
    } catch (e) {
        data = { title: 'Trending Rant!', body: 'A new rant is trending now.' };
    }
    const title = data.title || 'Trending Rant!';
    const options = {
        body: data.body || 'A new rant is trending now.',
        icon: '/assets/rant_logo.svg',
        badge: '/favicon-32x32.png',
        data: data.url ? { url: data.url } : {}
    };
    event.waitUntil(self.registration.showNotification(title, options));
});

// Notification click event
self.addEventListener('notificationclick', function (event) {
    event.notification.close();
    const url = event.notification.data && event.notification.data.url ? event.notification.data.url : '/';
    event.waitUntil(clients.openWindow(url));
});

const CACHE_VERSION = 'v20250630224654'; // Update this version on each deploy
const CACHE_WHITELIST = [
    'static-assets',
    'rants-api',
    'pages',
    // Add any other cache names you use
];

self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (!CACHE_WHITELIST.includes(cacheName)) {
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
    // Claim clients immediately so new SW takes control
    return self.clients.claim();
});
